import tkinter as tk
from tkinter import messagebox

#izveido virsotnes objektu
class Virs:
    #pieskir virsotnei atributus
    def __init__(self, id ,akmenuSk, p1, a1, p2, a2, lvl):
        self.id = id
        self.akmenuSk = akmenuSk
        self.p1 = p1
        self.a1 = a1
        self.p2 = p2
        self.a2 = a2
        self.lvl = lvl


#izveido koka strukturu
class Koks:
    #pieskir kokam atributus, kuros glabat virsotnes un lokus
    def __init__(self):
        self.virsotnes = []
        self.loki = dict()

    #funkcija lai pievienotu virsotni virsotnu kopai
    def piev_virs(self, Virs):
        self.virsotnes.append(Virs)


    #funkcija lai pievienotu loku loku kopai
    def piev_loku(self, sVirs, bVirs):
        self.loki[sVirs] = self.loki.get(sVirs,[]) + [bVirs]


#funkcija kas apraksta speles gajienu. ka vertibas panem gajiena veidu (2akmeni vai 3), virsotnu kopu, virsotni, kura sobrid atrodas un speletaju, kurs sak gajienu
def gajiens(gTips, genVirs, pasrV):

    #pasrV --> Pašreizējā virsotne
    #genVirs --> uzģenerēto virsotņu kopa
    #gTips --> gājiena tips (2 vai 3 akmeni nonemti)

    #ja akmeņi nav 0, tad izveido jaunas virsotnes id un aprekina tas akmenu skaitu
    if pasrV[1] - int(gTips) >= 0:
        global z
        jauns_ID = 'V' + str(z)
        jauni_akmeni = pasrV[1] - int(gTips)
        #virsotnes numurs
        z += 1




        #atjauno punktu skaitu balstoties uz speles noteikumiem atskiriba no gajiena
        #parbauda vai gajiena tips ir 2 vai 3
        if gTips == '2' or gTips == '3':
            #parbaude kas parbauda vai virsotnes atrodas viena limeni --> vai gajienu veica viens vai otrs speletajs
            if pasrV[6] % 2 != 0:
                #parbauda vai jaunas virsotnes akmenu skaits ir para vai nepara
                if (jauni_akmeni % 2) == 0 :
                    p1_jPunkti = pasrV[2] + 2
                    p2_jPunkti = pasrV[4]
                    a1_jAkmeni = pasrV[3] + int(gTips)
                    a2_jAkmeni = pasrV[5]
                else:
                    p1_jPunkti = pasrV[2] - 2
                    p2_jPunkti = pasrV[4]
                    a1_jAkmeni = pasrV[3] + int(gTips)
                    a2_jAkmeni = pasrV[5]
            else:
                if (pasrV[1] % 2 == 0):
                    p1_jPunkti = pasrV[2]
                    p2_jPunkti = pasrV[4] + 2
                    a1_jAkmeni = pasrV[3]
                    a2_jAkmeni = pasrV[5] + int(gTips)
                elif (pasrV[1] % 2 != 0):
                    p1_jPunkti = pasrV[2]
                    p2_jPunkti = pasrV[4] - 2
                    a1_jAkmeni = pasrV[3]
                    a2_jAkmeni = pasrV[5] + int(gTips)
        #ja gajiena tips nav 2 vai 3, tad jaunajam virsotnem pieskir pasreizejas virsotnes vertibas
        else:
            p1_jPunkti = pasrV[2]
            p2_jPunkti = pasrV[4]
            a1_jAkmeni = pasrV[3]
            a2_jAkmeni = pasrV[5]



        #nosaka jaunas virsotnes limeni
        jauns_LVL = pasrV[6] + 1
        #pieskir jaunajai virsotnei atributu vertibas
        jauna_Virs = Virs(jauns_ID, jauni_akmeni, p1_jPunkti, a1_jAkmeni, p2_jPunkti, a2_jAkmeni, jauns_LVL)

        test = False
        #mainigais kas norada virsotnes kartas skaitli kopa
        k = 0

        #parbauda vai jauna virsotne jau pastav koka
        while (not test) and (k < len(spele.virsotnes) - 1):
            if(spele.virsotnes[k].akmenuSk == jauna_Virs.akmenuSk) and (spele.virsotnes[k].p1 == jauna_Virs.p1) and (spele.virsotnes[k].a1 == jauna_Virs.a1) and (spele.virsotnes[k].p2 == jauna_Virs.p2) and (spele.virsotnes[k].a2 == jauna_Virs.a2) and (spele.virsotnes[k].lvl == jauna_Virs.lvl):
                test = True
            else:
                k += 1
        #ja nepastav pievieno kokam gan virsotni gan loku
        if not test:
            spele.piev_virs(jauna_Virs)
            genVirs.append([jauns_ID, jauni_akmeni, p1_jPunkti, a1_jAkmeni, p2_jPunkti, a2_jAkmeni, jauns_LVL])
            spele.piev_loku(pasrV[0], jauns_ID)


        #ja pastav tad pievieno tikai papildus loku kas aizved uz so virsotni
        else:
            z -= 1
            spele.piev_loku(pasrV[0], spele.virsotnes[k].id)

###############################

# Kods ir izveidots pēc minimax.py parauga, izņemot šoreiz ir divi citi mainīgie - alpha un beta

def AlphaBeta(akmentini, punkti, max_speletajs, alpha, beta):
    if akmentini == 0:
        return punkti, 0

    if max_speletajs:
        maxNovert = float('-inf')
        alpha = float('-inf')
        beta = float('inf')
        labakais_gaj = None
        for gajiens in [2,3]:
            if akmentini >= gajiens:
                atlikusie_akmentini = akmentini - gajiens
                punkti_jaunie = punkti + gajiens

                if atlikusie_akmentini % 2 == 0:
                    punkti_jaunie += 2
                else:
                    punkti_jaunie -= 2

                novertejums = AlphaBeta(atlikusie_akmentini, punkti_jaunie, False, alpha, beta)[0]
                if novertejums > maxNovert:
                    maxNovert = novertejums
                    labakais_gaj = gajiens

                alpha = max(alpha, novertejums)
                if beta <= alpha:
                    break

        return maxNovert, labakais_gaj
    else:
        minNovert = float('inf')
        labakais_gaj = None
        for gajiens in [2,3]:
            if akmentini >= gajiens:
                atlikusie_akmentini = akmentini - gajiens
                punkti_jaunie = punkti + gajiens

                if atlikusie_akmentini % 2 == 0:
                    punkti_jaunie += 2
                else:
                    punkti_jaunie -= 2

                novertejums = AlphaBeta(atlikusie_akmentini, punkti_jaunie, True, alpha, beta)[0]
                if novertejums < minNovert:
                    minNovert = novertejums
                    labakais_gaj = gajiens

                beta = min(beta, novertejums)
                if beta <= alpha:
                    break

        return minNovert, labakais_gaj
################################
# funkcija tiek definēta:
#virsotne - speles stāvoklis
#max_speletajs - norada, vai ir maksimizejosais speletajs
#dzilums_robeza - rekursijas dziluma ierobezojums
def MiniMax(virsotne,dzilums,max_speletajs):

    #parbaude vai uz galda nav akmentiņu vai ir sasniegs dziluma ierobezojums
    if virsotne.akmenuSk == 0 or dzilums == 0:

        return virsotne.p1 - virsotne.p2, None

    #ja tagadējais spēlētājs ir max, tiek inicializēts mainīgais maxNovert ar negatīvu bezgalību, lai nākamā novērtējuma vērtība būtu lielāka
    if max_speletajs:
        maxNovert= float('-inf')
        #tiek ņemts vērā labākais gajiens
        labakais_gajiens = None
        #cikls iet cauri iespējamajiem gājieniem - paņemt 2 vai 3 akmeņus
        for gajiens in [2,3]:
            if virsotne.akmenuSk >= gajiens: #pārbauda, vai ir pietiekami daudz akmeņu, lai izpilditu gājienu

                #izveidots jauns spēles stāvoklis pēc gājiena
                jauna_virsotne = Virs(0,virsotne.akmenuSk - gajiens,virsotne.p1,virsotne.a2,virsotne.p2+gajiens,virsotne.a2,virsotne.lvl+1)
                #rekursivi izsauc funkciju ar jauno spēles stāvokli, parsledzoties uz min speletaju un samazinot dziļuma ierobežojumu
                vertiba = MiniMax(jauna_virsotne, dzilums - 1,False)[0]
                #atjaunina maksimalo novertējumu un labako gajienu, ja ir atrasta labāka vērtība
                if vertiba > maxNovert:
                    maxNovert = vertiba
                    labakais_gajiens = gajiens
        # atgriež maksimālo novērtējumu un labāko gajienu maksimizējošam speletajam
        return maxNovert, labakais_gajiens

    else: #gājienu veic minimizējošais spēlētājs ar līdzīgu algoritmu, mēģinot minimizēt punktu skaitu
        minNovert = float('inf')
        for gajiens in [2,3]:
            if virsotne.akmenuSk >= gajiens:
                jauna_virsotne = Virs(0,virsotne.akmenuSk - gajiens,virsotne.p1,virsotne.a2,virsotne.p2+gajiens,virsotne.a2,virsotne.lvl+1)

                vertiba = MiniMax(jauna_virsotne,dzilums-1,True)[0]
                if vertiba < minNovert:
                    minNovert = vertiba
                    labakais_gajiens= gajiens
        return minNovert, 0


class GameGUI:
    def __init__(self, master):

        self.master = master
        self.master.title("Spēle ar akmeņiem")
        master.geometry("400x400")

        self.label = tk.Label(text="Laipni lūdzam spēlē! Izvēlieties akmeņu skaitu no 50 līdz 70")
        self.label.pack()

        self.akmen_entry = tk.Entry()
        self.akmen_entry.pack()

        self.start_button = tk.Button(text="Sākt spēli", command=self.play)
        self.start_button.pack()

        self.new_game_button = tk.Button(text="Jauna spēle", command=self.new_game)
        self.new_game_button.pack()

        self.saks_speli = tk.Label(text="Izvēlieties, kurš sāks spēli:")
        self.saks_speli.pack()

        self.stav = tk.StringVar(value='1')

        self.play_radio = tk.Radiobutton(text="Lietotājs", variable=self.stav, value='1')
        self.play_radio.pack()

        self.comp_radio = tk.Radiobutton(text="Dators", variable=self.stav, value='2')
        self.comp_radio.pack()

        self.info = tk.Label()
        self.info.pack()
        
        self.akmen_inf = tk.Label(text="")
        self.akmen_inf.pack()

        self.playp = tk.Label(text="")
        self.playp.pack()

        self.datorp = tk.Label(text="")
        self.datorp.pack()

        self.akmen_izvele = tk.Label(text="Izvēlieties ņemamo akmeņu skaitu:")
        self.akmen_izvele.pack()

        self.akmen_izvele_frame = tk.Frame()
        self.akmen_izvele_frame.pack()

        self.button2 = tk.Button(self.akmen_izvele_frame, text="2 akmeņi", command=lambda: self.play_move(2))
        self.button2.pack(side='left')
        self.button2.config(state="disabled")

        self.button3 = tk.Button(self.akmen_izvele_frame, text="3 akmeņi", command=lambda: self.play_move(3))
        self.button3.pack(side='right')
        self.button3.config(state="disabled")

        self.algo_label = tk.Label(text="Izvēlieties algoritmu:")
        self.algo_label.pack()

        self.algo_izvele = tk.StringVar(value='M')

        self.minimax_radio = tk.Radiobutton(text="MiniMax", variable=self.algo_izvele, value='M')
        self.minimax_radio.pack()

        self.alphabeta_radio = tk.Radiobutton(text="Alpha-Beta", variable=self.algo_izvele, value='A')
        self.alphabeta_radio.pack()

    def play(self):
        self.label.config(text="Spēle sākusies")
        try:
            self.akmeni = int(self.akmen_entry.get())
            if self.akmeni>70 or self.akmeni<50:
                self.label.config(text="!Izvēlieties akmeņu skaitu no 50 līdz 70!")
                return
            self.uzsacejs = self.stav.get()
            self.tagad_stavoklis = Virs('V1', self.akmeni, 0, 0, 0, 0, 1)
            self.speletaja_punkti = 0
            self.datora_punkti = 0
            self.algoritms= self.algo_izvele.get()
            if self.tagad_stavoklis.akmenuSk > 0 and self.uzsacejs == '2' and self.algoritms == 'M':
                self.comp_move()
                self.button2.config(state="normal")
                self.button3.config(state="normal")
            else:
                self.button2.config(state="normal")
                self.button3.config(state="normal")
        except ValueError:
            self.label.config(text="Ievadiet pareizo akmeņu skaitu.")
        self.start_button.config(state="disabled")

    def play_move(self,move):
        self.tagad_stavoklis.akmenuSk -= move
        self.speletaja_punkti += move
        if self.tagad_stavoklis.akmenuSk % 2 == 0:
            self.speletaja_punkti += 2
        else:
            self.speletaja_punkti -= 2
        self.game_over_check()
        self.comp_move()

    def comp_move(self):
        if self.algoritms == 'M':
            self.dators_izvele = MiniMax(self.tagad_stavoklis, 1, True)[1]


        elif self.algoritms == 'A':
            dators_izvele = AlphaBeta(self.tagad_stavoklis.akmenuSk,self.datora_punkti,True)

        if self.dators_izvele is not None:
            self.tagad_stavoklis.akmenuSk -= self.dators_izvele
            self.datora_punkti += self.dators_izvele
            if self.tagad_stavoklis.akmenuSk % 2 == 0:
                self.datora_punkti += 2
            else:
                self.datora_punkti -=2
            self.game_over_check()

    def new_game(self):
        self.label.config(text="Izvēlieties akmeņu skaitu (no 50 līdz 70):")
        self.akmen_entry.delete(0, tk.END)
        self.akmen_inf.config(text="")
        self.playp.config(text="")
        self.datorp.config(text="")
        self.button2.config(state="disabled")
        self.button3.config(state="disabled")
        self.start_button.config(state="normal")

    def game_over_check(self):
        self.akmen_inf.config(text=f"Atlikuši akmeņi: {self.tagad_stavoklis.akmenuSk}")
        self.playp.config(text=f"Spēlētāja punkti: {self.speletaja_punkti}")
        self.datorp.config(text=f"Datora punkti: {self.datora_punkti}")
        if self.tagad_stavoklis.akmenuSk <=0:
            if self.speletaja_punkti == self.datora_punkti:
                self.akmen_inf.config(text=f"Neizšķirts!",fg="seashell4",font=(10))
            elif self.speletaja_punkti > self.datora_punkti:
                self.akmen_inf.config(text=f"Uzvara!",fg="lime green",font=(10))
                self.playp.config(text=f"Spēlētāja punkti: {self.speletaja_punkti}")
            else:
                self.akmen_inf.config(text=f"Dators uzvar!",fg="maroon",font=(10))
            self.button2.config(state="disabled")
            self.button3.config(state="disabled")

root = tk.Tk()
game_gui = GameGUI(root)
root.mainloop()
